"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var driver = null;
var absent = new String("absent");

var VirtualRoot = function () {
  function VirtualRoot(view, model, address) {
    _classCallCheck(this, VirtualRoot);

    this.view = view;
    this.model = model;
    this.address = address;
  }

  _createClass(VirtualRoot, [{
    key: "renderWith",
    value: function renderWith(current) {
      var exception = absent;
      var previous = driver;
      driver = current;

      try {
        driver.render(this.view(this.model, this.address));
      } catch (error) {
        exception = error;
      }

      driver = previous;

      if (exception != absent) {
        throw exception;
      }
    }
  }]);

  return VirtualRoot;
}();

VirtualRoot.prototype.$type = "VirtualRoot";

var LazyNode = exports.LazyNode = function () {
  function LazyNode(tagName, properties, children) {
    _classCallCheck(this, LazyNode);

    this.tagName = tagName;
    this.properties = properties;
    this.children = children;
    this.key = properties == null ? null : properties.key;
  }

  _createClass(LazyNode, [{
    key: "force",
    value: function force() {
      if (driver == null) {
        throw TypeError('LazyTree may only be forced from with in the Root.renderWith(driver) call');
      }

      return driver.node(this.tagName, this.properties, this.children);
    }
  }]);

  return LazyNode;
}();

LazyNode.prototype.$type = "LazyTree";

var LazyThunk = function () {
  function LazyThunk(key, view, args) {
    _classCallCheck(this, LazyThunk);

    this.key = key;
    this.view = view;
    this.args = args;
  }

  _createClass(LazyThunk, [{
    key: "force",
    value: function force() {
      var _driver;

      if (driver == null) {
        throw TypeError('LazyTree may only be forced from with in the Root.renderWith(driver) call');
      }

      return (_driver = driver).thunk.apply(_driver, [this.key, this.view].concat(_toConsumableArray(this.args)));
    }
  }]);

  return LazyThunk;
}();

LazyThunk.prototype.$type = "LazyTree";

var root = exports.root = function root(view, model, address) {
  return new VirtualRoot(view, model, address);
};

var text = exports.text = function text(content) {
  return driver == null ? content : driver.text == null ? content : driver.text(content);
};

var node = exports.node = function node(tagName, properties, children) {
  return driver == null ? new LazyNode(tagName, properties, children) : driver.node(tagName, properties, children);
};

var thunk = exports.thunk = function thunk(key, view) {
  for (var _len = arguments.length, args = Array(_len > 2 ? _len - 2 : 0), _key = 2; _key < _len; _key++) {
    args[_key - 2] = arguments[_key];
  }

  var _driver2;

  return driver == null ? new LazyThunk(key, view, args) : (_driver2 = driver).thunk.apply(_driver2, [key, view].concat(args));
};
//# sourceMappingURL=data:application/json;base64,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LFFBRkY7U0FJRSxVQUFVLElBQVYsR0FDQSxJQUFJLFFBQUosQ0FBYSxPQUFiLEVBQXNCLFVBQXRCLEVBQWtDLFFBQWxDLENBREEsR0FFQSxPQUFPLElBQVAsQ0FBWSxPQUFaLEVBQXFCLFVBQXJCLEVBQWlDLFFBQWpDLENBRkE7Q0FKRjs7QUFTSyxJQUFNLHdCQUNYLFNBRFcsS0FDWCxDQUFFLEdBQUYsRUFDRSxJQURGO29DQUVLOzs7Ozs7U0FFSCxVQUFVLElBQVYsR0FDQSxJQUFJLFNBQUosQ0FBYyxHQUFkLEVBQW1CLElBQW5CLEVBQXlCLElBQXpCLENBREEsR0FFQSxvQkFBTyxLQUFQLGtCQUFhLEtBQUssYUFBUyxLQUEzQixDQUZBO0NBSkYiLCJmaWxlIjoiZG9tLmpzIiwic291cmNlc0NvbnRlbnQiOlsiLyogQGZsb3cgKi9cblxuLyo6OlxuaW1wb3J0IHR5cGUge1RleHQsIEtleSwgVGFnTmFtZSwgUHJvcGVydHlEaWN0aW9uYXJ5fSBmcm9tIFwiLi9jb3JlXCJcbmltcG9ydCB0eXBlIHtWaXJ0dWFsVGV4dCwgVmlydHVhbE5vZGUsIERPTSwgTGF6eVRyZWUsIFRodW5rfSBmcm9tIFwiLi9jb3JlXCJcbmltcG9ydCB0eXBlIHtEcml2ZXJ9IGZyb20gXCIuL2RyaXZlclwiXG5pbXBvcnQgdHlwZSB7QWRkcmVzc30gZnJvbSBcIi4vc2lnbmFsXCJcblxuZXhwb3J0IHR5cGUge1RleHQsIEtleSwgVGFnTmFtZSwgRE9NfVxuKi9cblxubGV0IGRyaXZlci8qOj9Ecml2ZXIqLyA9IG51bGxcbmNvbnN0IGFic2VudCA9IG5ldyBTdHJpbmcoXCJhYnNlbnRcIilcblxuY2xhc3MgVmlydHVhbFJvb3QgLyo6Ojxtb2RlbCwgYWN0aW9uPiovIHtcbiAgLyo6OlxuICAkdHlwZTogXCJWaXJ0dWFsUm9vdFwiO1xuXG4gIHZpZXc6IChtb2RlbDptb2RlbCwgYWRkcmVzczpBZGRyZXNzPGFjdGlvbj4pID0+IERPTTtcbiAgbW9kZWw6IG1vZGVsO1xuICBhZGRyZXNzOiBBZGRyZXNzPGFjdGlvbj47XG4gICovXG4gIGNvbnN0cnVjdG9yKFxuICAgIHZpZXcvKjoobW9kZWw6bW9kZWwsIGFkZHJlc3M6QWRkcmVzczxhY3Rpb24+KSA9PiBET00qL1xuICAsIG1vZGVsLyo6bW9kZWwqL1xuICAsIGFkZHJlc3MvKjpBZGRyZXNzPGFjdGlvbj4qL1xuICApIHtcbiAgICB0aGlzLnZpZXcgPSB2aWV3XG4gICAgdGhpcy5tb2RlbCA9IG1vZGVsXG4gICAgdGhpcy5hZGRyZXNzID0gYWRkcmVzc1xuICB9XG4gIHJlbmRlcldpdGgoY3VycmVudC8qOkRyaXZlciovKSB7XG4gICAgbGV0IGV4Y2VwdGlvbiA9IGFic2VudFxuICAgIGNvbnN0IHByZXZpb3VzID0gZHJpdmVyXG4gICAgZHJpdmVyID0gY3VycmVudFxuXG4gICAgdHJ5IHtcbiAgICAgIGRyaXZlci5yZW5kZXIodGhpcy52aWV3KHRoaXMubW9kZWwsIHRoaXMuYWRkcmVzcykpXG4gICAgfVxuICAgIGNhdGNoKGVycm9yKSB7XG4gICAgICBleGNlcHRpb24gPSBlcnJvclxuICAgIH1cblxuICAgIGRyaXZlciA9IHByZXZpb3VzXG5cbiAgICBpZiAoZXhjZXB0aW9uICE9IGFic2VudCkge1xuICAgICAgdGhyb3cgZXhjZXB0aW9uXG4gICAgfVxuICB9XG59XG5WaXJ0dWFsUm9vdC5wcm90b3R5cGUuJHR5cGUgPSBcIlZpcnR1YWxSb290XCJcblxuZXhwb3J0IGNsYXNzIExhenlOb2RlIHtcbiAgLyo6OlxuICAkdHlwZTogXCJMYXp5VHJlZVwiO1xuXG4gIHRhZ05hbWU6IFRhZ05hbWU7XG4gIHByb3BlcnRpZXM6ID9Qcm9wZXJ0eURpY3Rpb25hcnk7XG4gIGNoaWxkcmVuOiA/QXJyYXk8RE9NPjtcbiAga2V5OiA/S2V5O1xuICBuYW1lc3BhY2U6IHN0cmluZztcbiAgKi9cbiAgY29uc3RydWN0b3IodGFnTmFtZS8qOlRhZ05hbWUqLywgcHJvcGVydGllcy8qOj9Qcm9wZXJ0eURpY3Rpb25hcnkqLywgY2hpbGRyZW4vKjo/QXJyYXk8RE9NPiovKSB7XG4gICAgdGhpcy50YWdOYW1lID0gdGFnTmFtZVxuICAgIHRoaXMucHJvcGVydGllcyA9IHByb3BlcnRpZXNcbiAgICB0aGlzLmNoaWxkcmVuID0gY2hpbGRyZW5cbiAgICB0aGlzLmtleSA9IHByb3BlcnRpZXMgPT0gbnVsbCA/IG51bGwgOiBwcm9wZXJ0aWVzLmtleVxuICB9XG4gIGZvcmNlKCkvKjpWaXJ0dWFsTm9kZSovIHtcbiAgICBpZiAoZHJpdmVyID09IG51bGwpIHtcbiAgICAgIHRocm93IFR5cGVFcnJvcignTGF6eVRyZWUgbWF5IG9ubHkgYmUgZm9yY2VkIGZyb20gd2l0aCBpbiB0aGUgUm9vdC5yZW5kZXJXaXRoKGRyaXZlcikgY2FsbCcpXG4gICAgfVxuXG4gICAgcmV0dXJuIGRyaXZlci5ub2RlKHRoaXMudGFnTmFtZSwgdGhpcy5wcm9wZXJ0aWVzLCB0aGlzLmNoaWxkcmVuKVxuICB9XG59XG5MYXp5Tm9kZS5wcm90b3R5cGUuJHR5cGUgPSBcIkxhenlUcmVlXCI7XG5cbmNsYXNzIExhenlUaHVuayB7XG4gIC8qOjpcbiAgJHR5cGU6IFwiTGF6eVRyZWVcIjtcblxuICBrZXk6IEtleTtcbiAgdmlldzogRnVuY3Rpb247XG4gIGFyZ3M6IEFycmF5PGFueT47XG4gICovXG4gIGNvbnN0cnVjdG9yKGtleS8qOktleSovLCB2aWV3Lyo6RnVuY3Rpb24qLywgYXJncy8qOkFycmF5PGFueT4qLykge1xuICAgIHRoaXMua2V5ID0ga2V5XG4gICAgdGhpcy52aWV3ID0gdmlld1xuICAgIHRoaXMuYXJncyA9IGFyZ3NcbiAgfVxuICBmb3JjZSgpLyo6VGh1bmsqLyB7XG4gICAgaWYgKGRyaXZlciA9PSBudWxsKSB7XG4gICAgICB0aHJvdyBUeXBlRXJyb3IoJ0xhenlUcmVlIG1heSBvbmx5IGJlIGZvcmNlZCBmcm9tIHdpdGggaW4gdGhlIFJvb3QucmVuZGVyV2l0aChkcml2ZXIpIGNhbGwnKVxuICAgIH1cblxuICAgIHJldHVybiBkcml2ZXIudGh1bmsodGhpcy5rZXksIHRoaXMudmlldywgLi4udGhpcy5hcmdzKVxuICB9XG59XG5MYXp5VGh1bmsucHJvdG90eXBlLiR0eXBlID0gXCJMYXp5VHJlZVwiO1xuXG5leHBvcnQgY29uc3Qgcm9vdCA9IC8qOjo8bW9kZWwsIGFjdGlvbj4qL1xuICAoIHZpZXcvKjoobW9kZWw6bW9kZWwsIGFkZHJlc3M6QWRkcmVzczxhY3Rpb24+KSA9PiBET00qL1xuICAsIG1vZGVsLyo6bW9kZWwqL1xuICAsIGFkZHJlc3MvKjpBZGRyZXNzPGFjdGlvbj4qL1xuICApLyo6VmlydHVhbFJvb3Q8bW9kZWwsIGFjdGlvbj4qLyA9PlxuICBuZXcgVmlydHVhbFJvb3RcbiAgKCB2aWV3XG4gICwgbW9kZWxcbiAgLCBhZGRyZXNzXG4gIClcblxuZXhwb3J0IGNvbnN0IHRleHQgPVxuICAoY29udGVudC8qOlRleHQqLykvKjpUZXh0IHwgVmlydHVhbFRleHQqLyA9PlxuICAoIGRyaXZlciA9PSBudWxsXG4gID8gY29udGVudFxuICA6IGRyaXZlci50ZXh0ID09IG51bGxcbiAgPyBjb250ZW50XG4gIDogZHJpdmVyLnRleHQoY29udGVudClcbiAgKVxuXG5leHBvcnQgY29uc3Qgbm9kZSA9XG4gICggdGFnTmFtZS8qOlRhZ05hbWUqL1xuICAsIHByb3BlcnRpZXMvKjo/UHJvcGVydHlEaWN0aW9uYXJ5Ki9cbiAgLCBjaGlsZHJlbi8qOj9BcnJheTxET00+Ki9cbiAgKS8qOlZpcnR1YWxOb2RlIHwgTGF6eVRyZWU8VmlydHVhbE5vZGU+Ki8gPT5cbiAgKCBkcml2ZXIgPT0gbnVsbFxuICA/IG5ldyBMYXp5Tm9kZSh0YWdOYW1lLCBwcm9wZXJ0aWVzLCBjaGlsZHJlbilcbiAgOiBkcml2ZXIubm9kZSh0YWdOYW1lLCBwcm9wZXJ0aWVzLCBjaGlsZHJlbilcbiAgKVxuXG5leHBvcnQgY29uc3QgdGh1bmsgPSAvKjo6PGEsIGIsIGMsIGQsIGUsIGYsIGcsIGgsIGksIGo+Ki9cbiAgKCBrZXkvKjpzdHJpbmcqL1xuICAsIHZpZXcvKjooYTphLCBiOmIsIGM6YywgZDpkLCBlOmUsIGY6ZiwgZzpnLCBoOmgsIGk6aSwgajpqKSA9PiBET00qL1xuICAsIC4uLmFyZ3MvKjpBcnJheTxhbnk+Ki9cbiAgKS8qOlRodW5rIHwgTGF6eVRyZWU8VGh1bms+Ki8gPT5cbiAgKCBkcml2ZXIgPT0gbnVsbFxuICA/IG5ldyBMYXp5VGh1bmsoa2V5LCB2aWV3LCBhcmdzKVxuICA6IGRyaXZlci50aHVuayhrZXksIHZpZXcsIC4uLmFyZ3MpXG4gIClcbiJdfQ==